### 1. 所有权的规则
 - 每个值都有一个变量，这个变量是该值的所有者
 - 每个值同时只能有一个作者
 - 当所有者超出作用域(scope)时，该值将被删除

### 2. 变量的作用域
- Scope就是程序中一个项目的有效范围
```rust
    fn main() {
    // s 不可用
    let s = "hello";// s可用
                    // 可以对s进行相关操作
    }// s作用域到此结束，s不可再用
```

### 3. String类型的值

 3.1 创建String类型的值
    - 可以使用from函数从字符串字面值创建出String类型
    ```rust
        let s = String::from("hello");// :: 表示from是String类型下的函数
    ```

3.2 内存和分配
- 字符串字面值，在编译时就知道它的内容了，其文本内容直接被硬编码到最终的可执行文件里
        - 速度快、高效，是因为其不可变性
    - string类型，为了支持可变性，需要在heap上分配内存来保存编译时未知的文本内容
        - 操作系统必须在运行时来请求内存
            - 这步通过调用String::from 来实现
        - 当用完String之后，需要使用某种方式将内存返回给操作系统
            - 这步，在拥有GC的语言中，GC会跟踪清理不再使用的内存
            - 没有GC，就需要我们去识别内存何时不再使用，并调用代码将它返回
                - 如果忘了，那就浪费内存
                - 如果提前做了，变量就会非法
                - 如果做了两次，也是bug，必须一次分配对应一次释放
    - rust采用了不同的方式： 对于某个值来说，当拥有它的变量走出作用范围时，内存会立即自动的交换给操作系统
    - drop 函数
    
### 4. 变量和数据交互的方式：移动(Move)
- 4.1 简单类型
    - 多个变量可以与同一个数据使用一种独特的方式来交互
    ```rust
        let x = 5;
        let y = x;
    ```
    - 整数是已知且固定大小的简单的值，这两个5被压到了stack中

- 4.2 复杂类型

    let s1 = String::from("hello,world");
    let s2 = s1;
    - 当把s1赋给s2，String的数据被复制了一份
        - 当在stack上复制了一份指针、长度、容量
        - 并没有复制指针所指向的heap上的数据
    - 当变量离开作用域时，Rust会自动调用drop函数，并将变量使用的heap内存释放
    - 当s1、s2离开作用域时，它们都会尝试释放相同的内存：
        - 二次释放bug
        - 为了保存内存安全：
            - Rust没有尝试复制被分配的内存
            - Rust让s1失效
                
- 4.3 变量和数据交互的方式： 移动(Move)
    - 浅拷贝(shallow copy)
    - 深拷贝(deep copy)
    - 你也许会将复制指针、长度、容量视为浅拷贝，但由于Rust让s1失效了，所以我们用一个新的术语：移动(Move)
    - 隐含的一个设计原则: Rust不会自动创建数据的深拷贝
        - 就运行时性能而言，任何自动赋值的操作都是廉价的
    
- 4.4 Clone(针对heap)

如果真想对heap上面的String数据进行深度拷贝，而不仅仅是stack上的数据，可以使用clone方法
```rust
    fn main(){
        let s1 = String::from("hello");
        let s2 = s1.clone();

        println!("{},{}", s1, s2);
    }
```

- 4.5 复制
```rust
    fn main() {
        let x = 5;
        let y = x;
        println!("{},{}",x,y);
    }
```

- Copy trait: 可以用于像整数这样完全存放在stack上面的类型
    - 如果一个类型实现了Copy这个trait，那么旧的变量在赋值后仍然可用
    - 如果一个类型或者该类型的一部分实现了Drop trait，那么Rust不允许它再去实现Copy trait了
    - 一些拥有Copy trait的类型
        - 任何简单标量的组合类型都可以是Copy的
        - 任何需要分配内存或某种资源的都不是Copy的
        - 一些拥有Copy trait的类型：
            - 所有的整数类型： 例如u32
            - 所有的浮点类型，例如f64
            - char
            - bool
            - Tuple，如果所有的字段都是Copy的
                - (i32,i32) 是
                - (i32, String)不是